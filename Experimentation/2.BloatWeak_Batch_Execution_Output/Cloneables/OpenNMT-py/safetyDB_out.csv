,dep,version,filepath,bloated,cve,affected versions,advisory
0,bitsandbytes,>=0.39.0,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,no one,no one,no one
1,pyrouge,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,no one,no one,no one
2,scipy,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,CVE-2013-4251,">=0,<0.12.1",The scipy.weave component in SciPy before 0.12.1 creates insecure temporary directories.
3,rapidfuzz,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,no one,no one,no one
4,apex,==700d6825e205732c1d6be511306ca4e595297070,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,no one,no one,no one
5,sentencepiece,">=0.1.94,<0.1.98",/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,no one,no one,no one
6,safetensors,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,no one,no one,no one
7,subword-nmt,>=0.3.7,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,no one,no one,no one
8,spacy,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/requirements.opt.txt,False,no one,no one,no one
9,torch,">=1.13,<2.1",/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2022-45907,">=0,<1.13.1","Torch 1.13.1 includes a fix for CVE-2022-45907: In PyTorch before trunk/89695, torch.jit.annotations.parse_type_line can cause arbitrary code execution because eval is used unsafely.
https://github.com/pytorch/pytorch/issues/88868"
10,configargparse,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
11,ctranslate2,">=3.2,<4",/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
12,tensorboard,>=2.3,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
13,flask,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2019-1010083,<0.12.3,"Flask 0.12.3 includes a fix for CVE-2019-1010083: Unexpected memory usage. The impact is denial of service. The attack vector is crafted encoded JSON data. NOTE: this may overlap CVE-2018-1000656.
https://github.com/pallets/flask/pull/2695/commits/0e1e9a04aaf29ab78f721cfc79ac2a691f6e3929"
14,flask,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2018-1000656,<0.12.3,flask version Before 0.12.3 contains a CWE-20: Improper Input Validation vulnerability in flask that can result in Large amount of memory usage possibly leading to denial of service. This attack appear to be exploitable via Attacker provides JSON data in incorrect encoding. This vulnerability appears to have been fixed in 0.12.3.
15,flask,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,PVE-2021-25820,<0.6.1,flask 0.6.1 fixes a security problem that allowed clients to download arbitrary files  if the host server was a windows based operating system and the client  uses backslashes to escape the directory the files where exposed from.
16,flask,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2023-30861,"<2.2.5,>=2.3.0,<2.3.2","Flask is a lightweight WSGI web application framework. When all of the following conditions are met, a response containing data intended for one client may be cached and subsequently sent by the proxy to other clients. If the proxy also caches 'Set-Cookie' headers, it may send one client's 'session' cookie to other clients. The severity depends on the application's use of the session and the proxy's behavior regarding cookies. The risk depends on all these conditions being met.

1. The application must be hosted behind a caching proxy that does not strip cookies or ignore responses with cookies.
2. The application sets 'session.permanent = True'
3. The application does not access or modify the session at any point during a request.
4. 'SESSION_REFRESH_EACH_REQUEST' enabled (the default).
5. The application does not set a 'Cache-Control' header to indicate that a page is private or should not be cached.

This happens because vulnerable versions of Flask only set the 'Vary: Cookie' header when the session is accessed or modified, not when it is refreshed (re-sent to update the expiration) without being accessed or modified. This issue has been fixed in versions 2.3.2 and 2.2.5."
17,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,PVE-2021-36764,<0.9.0,"Waitress 0.9.0 checks for line feed/carriage to prevent HTTP Response Splitting attacks in the status line or the key of a header. 
https://github.com/Pylons/waitress/pull/124
https://github.com/Pylons/waitress/issues/122"
18,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,PVE-2021-26174,<1.0.0,Waitress before 1.0.0 drops HTTP headers that contain an underscore in the key when received from a client. This is to stop any possible underscore/dash conflation that may lead to security issues. See: https://github.com/Pylons/waitress/pull/80 and https://www.djangoproject.com/weblog/2015/jan/13/security/
19,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,PVE-2021-26390,<1.2.0b1,waitress 1.2.0b1 provides a new security feature when using Waitress behind a proxy in that it is possible to remove untrusted proxy headers thereby making sure that downstream WSGI applications don't accidentally use those proxy headers to make security decisions
20,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2019-16785,<1.4.0,"Waitress 1.4.0 includes a fix for CVE-2019-16785: Waitress through version 1.3.1 implemented a ""MAY"" part of the RFC7230 which states: ""Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR."" Unfortunately if a front-end server does not parse header fields with an LF the same way as it does those with a CRLF it can lead to the front-end and the back-end server parsing the same HTTP message in two different ways. This can lead to a potential for HTTP request smuggling/splitting whereby Waitress may see two requests while the front-end server only sees a single HTTP message. 
https://github.com/Pylons/waitress/security/advisories/GHSA-pg36-wpm5-g57p"
21,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2019-16786,<1.4.0,"Waitress through version 1.3.1 would parse the Transfer-Encoding header and only look for a single string value, if that value was not chunked it would fall through and use the Content-Length header instead. According to the HTTP standard Transfer-Encoding should be a comma separated list, with the inner-most encoding first, followed by any further transfer codings, ending with chunked. Requests sent with: ""Transfer-Encoding: gzip, chunked"" would incorrectly get ignored, and the request would use a Content-Length header instead to determine the body size of the HTTP message. This could allow for Waitress to treat a single request as multiple requests in the case of HTTP pipelining. This issue is fixed in Waitress 1.4.0."
22,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2019-16789,<1.4.1,"In Waitress through version 1.4.0, if a proxy server is used in front of waitress, an invalid request may be sent by an attacker that bypasses the front-end and is parsed differently by waitress leading to a potential for HTTP request smuggling. Specially crafted requests containing special whitespace characters in the Transfer-Encoding header would get parsed by Waitress as being a chunked request, but a front-end server would use the Content-Length instead as the Transfer-Encoding header is considered invalid due to containing invalid characters. If a front-end server does HTTP pipelining to a backend Waitress server this could lead to HTTP request splitting which may lead to potential cache poisoning or unexpected information disclosure. This issue is fixed in Waitress 1.4.1 through more strict HTTP field validation."
23,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2022-24761,<2.1.1,"Waitress 2.1.1 includes a fix for CVE-2022-24761: When using Waitress versions 2.1.0 and prior behind a proxy that does not properly validate the incoming HTTP request matches the RFC7230 standard, Waitress and the frontend proxy may disagree on where one request starts and where it ends. This would allow requests to be smuggled via the front-end proxy to waitress and later behavior. There are two classes of vulnerability that may lead to request smuggling that are addressed by this advisory: The use of Python's 'int()' to parse strings into integers, leading to '+10' to be parsed as '10'', or '0x01' to be parsed as '1', where as the standard specifies that the string should contain only digits or hex digits; and Waitress does not support chunk extensions, however it was discarding them without validating that they did not contain illegal characters. A workaround is available. When deploying a proxy in front of waitress, turning on functionality to make sure that the request matches the RFC7230 standard. Certain proxy servers may not have this functionality.
https://github.com/Pylons/waitress/security/advisories/GHSA-4f7p-27jc-3c36"
24,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2019-16792,<=1.3.1,"Waitress through version 1.3.1 allows request smuggling by sending the Content-Length header twice. Waitress would fold a double Content-Length header and due to being unable to cast the now comma separated value to an integer would set the Content-Length to 0 internally. If two Content-Length headers are sent in a single request, Waitress would treat the request as having no body, thereby treating the body of the request as a new request in HTTP pipelining. This issue is fixed in Waitress 1.4.0."
25,waitress,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2022-31015,">=2.1.0,<2.1.2","Waitress 2.1.2 includes a fix for CVE-2022-31015: Waitress versions 2.1.0 and 2.1.1 may terminate early due to a thread closing a socket while the main thread is about to call select(). This will lead to the main thread raising an exception that is not handled and then causing the entire application to be killed. This issue has been fixed in Waitress 2.1.2 by no longer allowing the WSGI thread to close the socket. Instead, that is always delegated to the main thread. There is no workaround for this issue, however, users using waitress behind a reverse proxy server are less likely to have issues if the reverse proxy always reads the full response.
https://github.com/Pylons/waitress/security/advisories/GHSA-f5x9-8jwc-25rw"
26,pyonmttok,">=1.35,<2",/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
27,pyyaml,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2017-18342,<4,Pyyaml before 4 uses ``yaml.load`` which has been assigned CVE-2017-18342.
28,pyyaml,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2020-1747,<5.3.1,"Pyyaml 5.3.1 includes a fix for CVE-2020-1747: A vulnerability was discovered in the PyYAML library in versions before 5.3.1, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. An attacker could use this flaw to execute arbitrary code on the system by abusing the python/object/new constructor."
29,pyyaml,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2020-14343,<5.4,"Pyyaml version 5.4 includes a fix for CVE-2020-14343: A vulnerability was discovered in the PyYAML library in versions before 5.4, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. This flaw allows an attacker to execute arbitrary code on the system by abusing the python/object/new constructor. This flaw is due to an incomplete fix for CVE-2020-1747.
https://bugzilla.redhat.com/show_bug.cgi?id=1860466"
30,pyyaml,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,CVE-2019-20477,">=5.1,<=5.1.2","PyYAML 5.1 through 5.1.2 has insufficient restrictions on the load and load_all functions because of a class deserialization issue, e.g., Popen is a class in the subprocess module. See CVE-2019-20477. NOTE: this issue exists because of an incomplete fix for CVE-2017-18342."
31,sacrebleu,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
32,rapidfuzz,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
33,pyahocorasick,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
34,fasttext-wheel,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
35,spacy,==*,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/setup.py,False,no one,no one,no one
36,sphinxcontrib.mermaid,==0.8.1,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,no one,no one,no one
37,sphinx_markdown_tables,==0.0.17,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,no one,no one,no one
38,docutils,==0.19,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,CVE-2009-5042,">=0.5,<0.6","Docutils 0.6 includes a fix for CVE-2009-5042: Python-docutils allows insecure usage of temporary files.
https://github.com/advisories/GHSA-cg75-6938-wx58"
39,sphinx,==6.1.3,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,no one,no one,no one
40,sphinx-rtd-theme,==0.4.3,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,no one,no one,no one
41,sphinxcontrib.bibtex,==2.5.0,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,no one,no one,no one
42,Jinja2,==3.0.3,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,CVE-2019-10906,">=0,<2.10.1","In Pallets Jinja before 2.10.1, str.format_map allows a sandbox escape."
43,Jinja2,==3.0.3,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,CVE-2014-0012,">=0,<2.7.3","FileSystemBytecodeCache in Jinja2 2.7.2 does not properly create temporary directories, which allows local users to gain privileges by pre-creating a temporary directory with a user's uid.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-1402."
44,sphinx-argparse,==0.2.5,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,no one,no one,no one
45,recommonmark,==0.6.0,/home/daniele/git/NICHE_projects/Repo/Cloneables/OpenNMT-py/docs/requirements.txt,False,no one,no one,no one
